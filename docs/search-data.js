window.Aiken.initSearch([{"doc":"aiken/merkle_patricia_forestry","title":"from_root","content":"from_root(root: ByteArray) -&gt; MerklePatriciaForestry\n since | &lt;code&gt;1.0.0&lt;/code&gt;\n ---   | ---\n\n Construct a new [MerklePatriciaForestry](#MerklePatriciaForestry) from its\n root. On-chain, we actually only need the / root\n\n The root MUST be 32-bytes long. For an empty trie, see [empty](#empty).","url":"aiken/merkle_patricia_forestry.html#from_root"},{"doc":"aiken/merkle_patricia_forestry","title":"is_empty","content":"is_empty(self: MerklePatriciaForestry) -&gt; Bool\n since | &lt;code&gt;1.0.0&lt;/code&gt;\n ---   | ---\n\n Check whether a [MerklePatriciaForestry](#MerklePatriciaForestry) is empty.\n\n ```aiken\n mpf.is_empty(mpf.empty()) == True\n ```","url":"aiken/merkle_patricia_forestry.html#is_empty"},{"doc":"aiken/merkle_patricia_forestry","title":"has","content":"has(\n  self: MerklePatriciaForestry,\n  key: ByteArray,\n  value: ByteArray,\n  proof: Proof,\n) -&gt; Bool\n since | &lt;code&gt;1.0.0&lt;/code&gt;\n ---   | ---\n\n Test whether an element is present in the trie with a specific value. This\n requires a [Proof](#Proof) of inclusion for the element. The latter can be\n obtained off-chain from the whole trie containing the element.\n\n Returns `False` when the element isn&#39;t in the tree.","url":"aiken/merkle_patricia_forestry.html#has"},{"doc":"aiken/merkle_patricia_forestry","title":"insert","content":"insert(\n  self: MerklePatriciaForestry,\n  key: ByteArray,\n  value: ByteArray,\n  proof: Proof,\n) -&gt; MerklePatriciaForestry\n since | &lt;code&gt;1.0.0&lt;/code&gt;\n ---   | ---\n\n Insert an element in the trie. This requires a [Proof](#Proof) of inclusion\n for the element. The latter can be obtained off-chain from the whole trie\n containing the element.\n\n #### Fails when\n\n - The [Proof](#Proof) is invalid.\n - There&#39;s already an element in the trie at the given key.","url":"aiken/merkle_patricia_forestry.html#insert"},{"doc":"aiken/merkle_patricia_forestry","title":"delete","content":"delete(\n  self: MerklePatriciaForestry,\n  key: ByteArray,\n  value: ByteArray,\n  proof: Proof,\n) -&gt; MerklePatriciaForestry\n since | &lt;code&gt;1.0.0&lt;/code&gt;\n ---   | ---\n\n Remove an element from the trie. This requires a [Proof](#Proof) of\n inclusion for the element. The latter can be obtained off-chain from the\n whole trie containing the element.\n\n #### Fails when\n\n - the [Proof](#Proof) is invalid\n - there is no element in the trie at the given key","url":"aiken/merkle_patricia_forestry.html#delete"},{"doc":"aiken/merkle_patricia_forestry","title":"update","content":"update(\n  self: MerklePatriciaForestry,\n  key: ByteArray,\n  proof: Proof,\n  old_value: ByteArray,\n  new_value: ByteArray,\n) -&gt; MerklePatriciaForestry\n since          | &lt;code&gt;1.1.0&lt;/code&gt;\n ---            | ---\n\n Update an element in the trie with a a new value. This requires a [Proof](#Proof)\n of the old element, to ensure its in the list, and a [Proof](#Proof) of the new\n element, to re-add it.\n\n Can be thought of as a delete, followed by an insert, but is able to do it with one fewer\n membership checks\n\n #### fails when\n\n - The [Proof](#Proof) is invalid.\n - There&#39;s no element in the trie at the given key.","url":"aiken/merkle_patricia_forestry.html#update"},{"doc":"aiken/merkle_patricia_forestry","title":"root","content":"root(self: MerklePatriciaForestry) -&gt; ByteArray\n since | &lt;code&gt;1.1.0&lt;/code&gt;\n ---   | ---\n\n Get the root hash digest of a [MerklePatriciaForestry](#MerklePatriciaForestry).","url":"aiken/merkle_patricia_forestry.html#root"},{"doc":"aiken/merkle_patricia_forestry","title":"MerklePatriciaForestry","content":"MerklePatriciaForestry\n since          | &lt;code&gt;1.0.0&lt;/code&gt;\n ---            | ---\n\n A Merkle Patricia Forestry, typically constructed from a root hash digest\n using [`from_root`](#from_root).\n\n ```aiken\n let trie =\n   mpf.from_root(\n     #&quot;225a4599b804ba53745538c83bfa699ecf8077201b61484c91171f5910a4a8f9&quot;,\n   )\n ```\n","url":"aiken/merkle_patricia_forestry.html#MerklePatriciaForestry"},{"doc":"aiken/merkle_patricia_forestry","title":"Neighbor","content":"Neighbor {\n  nibble: Int,\n  prefix: ByteArray,\n  root: ByteArray,\n}\n since          | &lt;code&gt;1.0.0&lt;/code&gt;\n ---            | ---\n\n A neighbor node used in a proof. See [Proof](#Proof) for details.\nNeighbor { nibble: Int, prefix: ByteArray, root: ByteArray }\n","url":"aiken/merkle_patricia_forestry.html#Neighbor"},{"doc":"aiken/merkle_patricia_forestry","title":"Proof","content":"Proof = List&lt;ProofStep&gt;\n since          | &lt;code&gt;1.0.0&lt;/code&gt;\n ---            | ---\n\n A Proof is a list of [Step](#Step) which is processed from left to right,\n which corresponds to the neighbor nodes along the _path_ to the element being\n proved.\n\n See [merkle-patricia-forestry/off-chain :: Proving](https://github.com/aiken-lang/merkle-patricia-forestry/tree/main/off-chain#proving)\n for details about generating a proof.\n","url":"aiken/merkle_patricia_forestry.html#Proof"},{"doc":"aiken/merkle_patricia_forestry","title":"ProofStep","content":"ProofStep {\n  Branch { skip: Int, neighbors: ByteArray }\n  Fork { skip: Int, neighbor: Neighbor }\n  Leaf { skip: Int, key: ByteArray, value: ByteArray }\n}\n since          | &lt;code&gt;1.0.0&lt;/code&gt;\n ---            | ---\n\n We distinguish three kind of proof steps: Branch, Fork and Leaf. Each step\n contains a `skip` value which corresponds to the length of the common prefix\n at that particular level.\n\n The details of each level is documented [in the wiki :: Proof Format](https://github.com/aiken-lang/merkle-patricia-forestry/wiki/Proof-format).\nBranch { skip: Int, neighbors: ByteArray }\n\nFork { skip: Int, neighbor: Neighbor }\n\nLeaf { skip: Int, key: ByteArray, value: ByteArray }\n","url":"aiken/merkle_patricia_forestry.html#ProofStep"},{"doc":"aiken/merkle_patricia_forestry","title":"empty","content":"empty: MerklePatriciaForestry\n since | &lt;code&gt;2.0.0&lt;/code&gt;\n ---   | ---\n\n Construct a new empty [MerklePatriciaForestry](#MerklePatriciaForestry).","url":"aiken/merkle_patricia_forestry.html#empty"},{"doc":"aiken/merkle_patricia_forestry","title":"aiken/merkle_patricia_forestry","content":" A Merkle Patricia Forestry (MPF) is a key:value structure which stores\n elements in a radix trie folowing a key, and where nodes also contains a\n cryptographic hash digest of the sub-trie or value they hold.\n\n This library enforces (through hashing) that we use trie of radix 16\n (hexadecimal alphabet). This means that each level in the trie has up to\n 16 branches.\n\n An MPF allows for checking membership, insertion and deletion in the trie\n using only root hashes and a succinct proofs. They are quite efficient in\n both cpu and mem units. And they also provide proofs that are a / lot smaller\n than traditional Merkle Patricia Trie; proofs remain however the / main\n limiting factor.\n\n Here&#39;s a little table that summarizes the average proof&#39;s sizes in bytes\n given a number of elements.\n\n We also consider the average memory and CPU execution units for verifying\n a proof for various sizes. Note that [`insert`](#insert) and\n [`delete`](#delete) require **two** proofs verifications.\n\n size | avg proof size | avg proof mem | avg proof cpu |\n ---: | -------------: | ------------: | ------------: |\n  10² |          250   | 70K           | 28M           |\n  10³ |          350   | 100K          | 42M           |\n  10⁴ |          460   | 130K          | 56M           |\n  10⁵ |          560   | 160K          | 70M           |\n  10⁶ |          670   | 190K          | 84M           |\n  10⁷ |          780   | 220K          | 98M           |\n  10⁸ |          880   | 250K          | 112M          |\n  10⁹ |          990   | 280K          | 126M          |","url":"aiken/merkle_patricia_forestry.html"}]);